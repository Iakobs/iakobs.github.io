<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">

    <channel>
        <title><![CDATA[Jacob Ibáñez Sánchez's blog]]></title>
        <link>http://blog.jacobibanez.com/blog/rss.xml</link>
        <description>RSS Feed for <![CDATA[Jacob Ibáñez Sánchez's blog]]></description>
        <pubDate>Mon, 26 Feb 2018 14:59:00 +0000</pubDate>
        <generator uri="http://sysgears.com/grain/docs/latest/">Grain</generator>
        <atom:link href="http://blog.jacobibanez.com/blog/rss.xml" rel="self" type="application/rss+xml" />

        
            <item>
                <guid>http://blog.jacobibanez.com/blog/posts/groovy-example/</guid>
                <title><![CDATA[Groovy example for Java developers]]></title>
                
                <pubDate>Sun, 25 Feb 2018 22:53:00 +0000</pubDate>
                <link><![CDATA[http://blog.jacobibanez.com/blog/posts/groovy-example/]]></link>
                <description><![CDATA[<div class="paragraph">
<p>The intent of this article is to show Java developers how <strong>powerful, concise and declarative Groovy is</strong> with a simple example. I hope this will whet your appetite for more Groovy fun! If that&#8217;s the case, my recommendation is to take a look at the <a href="http://www.groovy-lang.org/documentation.html">official documentation</a>.</p>
</div>
<div class="sect1">
<h2 id="_the_problem">The problem</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I want the content of a simple csv file to be transformed to a list of maps. Each item of the list is a row of the csv transformed to a map, ignoring the first one (which contains the headers). The keys of the map are the headers of the csv and the values, the row itself. All of them, obviously, split by a given separator.</p>
</div>
<div class="paragraph">
<p>This comes handy for many reasons. One of them is that this format is the same used by Groovy for returning database resultsets. As you&#8217;ll see right below, <strong>accessing data from lists and maps is very easy and intuitive with Groovy</strong>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_groovy_solution">A Groovy solution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>And here, a possible groovy solution! Please try to read the code and understand it by yourself before reading the comments below. You&#8217;ll find it surprisingly&#8230;&#8203; groovy!</p>
</div>
<script src="https://gist.github.com/Iakobs/08a5ecd7f8831849b29d8f227b11676f.js"></script>
<div class="paragraph">
<p>Whoa! That was a lot of magic! First of all, the approach I&#8217;ve chose to complete the task is to add a method to the <code>java.io.File</code> class that returns the desired result. The reason why I&#8217;ve chose such an unusual approach is simple: I can do it! Well, it&#8217;s also <strong>the most obvious one</strong>, why do I have to implement such a method anywhere else? The <code>java.io.File</code> class is the perfect place to be. In Groovy, you can achieve that in multiple ways.</p>
</div>
<div class="sect2">
<h3 id="_a_taste_of_groovy">A taste of Groovy</h3>
<div class="paragraph">
<p>But first, let&#8217;s take a closer look to this code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
</pre></td>
  <td class="code"><pre>    <span class="predefined-type">File</span> thisFile = delegate <span class="keyword">as</span> <span class="predefined-type">File</span>    <b class="conum">(1)</b>
    <span class="keyword">def</span> allFileLines = thisFile.readLines()    <b class="conum">(2)</b>

    isCsv thisFile    <b class="conum">(3)</b></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>So many things in so little lines of code! Firstly, you can see two ways of declaring variables in Groovy; with explicit typing and without it. <strong>The first way is equals to the java way</strong>. You declare the type of the variable, its name and its value. In this case, the value is the delegate of the closure (you can see that the delegate of a closure is like the <code>self</code> object). You can see as well the type coertion here with the <code>as</code> keyword. It&#8217;s basically like java coertion but with subtles differences out of the scope of this post.</p>
</li>
<li>
<p>The second way is with the <code>def</code> keyword. <strong>You don&#8217;t declare the type of the variable and the compiler can guess it for you</strong>. Does it means we can reuse the variable with several types? No! Groovy is a strong typed language, but it does the type checking at run time instead of at compile time. Well, in fact you can change that behaviour, but that&#8217;s a different kettle of fish! This variable is storing all the lines of the file by calling the <code>File.readLines()</code> method (which I think is amazing). You&#8217;ll see that <strong>Groovy has enhanced the Java platform with a bunch of methods everywhere</strong>. You can check them <a href="http://www.groovy-lang.org/gdk.html">here</a>.</p>
</li>
<li>
<p>Last but not least, we have a call to a method (a Closure, actually) declared in the first three lines of the script. <strong>Can you see that the method call is practically like written English?</strong> With good naming of methods and variables and the Groovy optional parentheses when calling to methods, this is easily achieved. The <code>isCsv</code> Closure simply asserts that the file name&#8217;s ends with the <code>csv</code> pattern.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_the_glory_of_metaprogramming">The Glory of Metaprogramming</h3>
<div class="paragraph">
<p>Now let&#8217;s see how we can add a method to an existing class without touching that class!</p>
</div>
<div class="listingblock">
<div class="title">Listing 1 - Adding the method to the File class</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
15
</pre></td>
  <td class="code"><pre><span class="comment">//add a new method to the File class, dynamically, accessing its metaclass</span>
<span class="predefined-type">File</span>.metaClass.toResultSet = { separator = <span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span> -&gt;   <b class="conum">(1)</b>

    <span class="predefined-type">File</span> thisFile = delegate <span class="keyword">as</span> <span class="predefined-type">File</span>
    <span class="predefined-type">List</span> allFileLines = thisFile.readLines()

    isCsv thisFile

    allFileLines.with {   <b class="conum">(2)</b>
        <span class="keyword">def</span> header = head().split(separator)    <b class="conum">(3)</b>
        <span class="keyword">def</span> rows = tail().collect { <span class="local-variable">it</span>.split(separator) }    <b class="conum">(4)</b>

        rows.collect { row -&gt; [header, row].transpose().collectEntries() }    <b class="conum">(5)</b>
    }
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Here we are <strong>accessing the <code>java.io.File</code> metaclass and adding the method directly</strong>, called <code>toResultSet</code>. The method implementation is declared as a Closure, which is an object that contains behaviour in favour of state. Being an object, a Closure is a first class citizen and can be passed around. You can think of it as a Java 8 lambda, but a Closure is by far better!</p>
</li>
<li>
<p>You&#8217;ve seen before that the <code>File.readLines()</code> method reads all the lines of a file. <strong>Groovy manages the i/o boilerplate for you</strong>. The <code>with</code> method here (available for all Groovy objects) receives a Closure as an argument with a special scope. By default, you have direct access to the caller (the list of strings in the current example). <strong>It makes successive calls to an object cleaner.</strong></p>
</li>
<li>
<p>As said before, since you have direct access to the list of lines of the file, you can access directly to <strong>the <code>head</code> method, which returns the first line of a collection</strong>. Note that we are storing this first line in a variable called <code>header</code>, with the <code>def</code> keyword. Remember that <strong>in Groovy you don&#8217;t have to type the type</strong> (pun intended), the compiler will guess it for you!</p>
</li>
<li>
<p>Again, we are directly accessing to the <code>tail</code> method, which returns all the elements of a collection, except the first one. We are also collecting a new list, applying a Closure that split each line with a given separator. The <code>it</code> variable is the content of each element of the collection. <strong>Every Closure has this implicit variable, which you can rename as you wish</strong> (and please, <em>do it</em> for the sake of clarity!).</p>
</li>
<li>
<p>A lot of things are happening here! First of all, <strong>you&#8217;re returning something without the <code>return</code> keyword</strong>. It&#8217;s completely optional. In addition, <strong>inside of a Closure, the result of evaluating the last line is always returned</strong>. But, what are we returning? Well, we are returning a list of maps, which was our first goal! In one line you&#8217;re collecting all the lines of a csv, except the header, split by a separator, transposing its header to each element, and then collecting the result to a map. Amazing. It might look confusing at first, and you can achieve the same result in other ways, of course! But <strong>the power of Groovy lets you do such a transformation in only one line of code</strong>, and it&#8217;s absolutely readable.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now we have our brand new <code>toResultSet</code> method added to the <code>java.io.File</code> class, let&#8217;s use it!</p>
</div>
<div class="listingblock">
<div class="title">Listing 2 - Using our brand new method</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
<strong>10</strong>
11
12
13
14
</pre></td>
  <td class="code"><pre><span class="comment">//create a fake csv file for testing the code</span>
<span class="keyword">def</span> resultSet = <span class="keyword">new</span> <span class="predefined-type">File</span>(<span class="string"><span class="delimiter">'</span><span class="content">fake.csv</span><span class="delimiter">'</span></span>).with {
    newWriter().withWriter { writer -&gt;
        writer &lt;&lt; [    <b class="conum">(1)</b>
                [<span class="string"><span class="delimiter">'</span><span class="content">Header1;Header2;Header3;Header4</span><span class="delimiter">'</span></span>],
                [<span class="string"><span class="delimiter">'</span><span class="content">CellA1;CellB1;CellC1;CellD1</span><span class="delimiter">'</span></span>],
                [<span class="string"><span class="delimiter">'</span><span class="content">CellA2;CellB2;CellC2;CellD2</span><span class="delimiter">'</span></span>],
                [<span class="string"><span class="delimiter">'</span><span class="content">CellA3;CellB3;CellC3;CellD3</span><span class="delimiter">'</span></span>]
        ].flatten().join(<span class="string"><span class="delimiter">'</span><span class="content">\n</span><span class="delimiter">'</span></span>)
    }
    deleteOnExit()
    <span class="comment">//call the brand new method we've just created!</span>
    <span class="keyword">return</span> toResultSet(<span class="string"><span class="delimiter">'</span><span class="content">;</span><span class="delimiter">'</span></span>)    <b class="conum">(2)</b>
}</pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We create a fake csv file for that purpose. Again, using the <code>with</code> method, we are working with a new instance of a File, but <strong>never assigning the instance to a variable</strong>. We call the <code>newWriter</code> method, that returns a writer on the file, and then using the <code>withWriter</code> on said writer. <strong>All these methods are dealing themselves with the opening and closing of streams</strong>, etc. Also, you can see an example of the renaming of the default <code>it</code> variable. We are renaming <code>it</code>  to <code>writer</code>. You can see the Groovy notation for creating lists as well. A simple pair of square brackets are enough for declaring a list. But, what kind of list? By default, Groovy creates an ArrayList.</p>
</li>
<li>
<p>Now we are explicitely returning a value from a Closure, and the value we are returning is the result of our new method! Note we are passing a parameter to the method, which is the separator. If you check back the declaration of the method, you&#8217;ll see this code: <code>separator = ',' &#8594;</code>. That&#8217;s, let&#8217;s say it this way, the method signature. But not only that, <strong>we&#8217;re declaring a default value for the separator argument!</strong> Fantastic!</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_testing_our_work">Testing our work</h3>
<div class="paragraph">
<p>Let&#8217;s check that our method is working as expected!</p>
</div>
<div class="listingblock">
<div class="title">Listing 3 - Testing our code</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td>
  <td class="code"><pre><span class="keyword">assert</span> resultSet[<span class="integer">0</span>] == [    <b class="conum">(1)</b>
        <span class="key">Header1</span>: <span class="string"><span class="delimiter">'</span><span class="content">CellA1</span><span class="delimiter">'</span></span>,
        <span class="key">Header2</span>: <span class="string"><span class="delimiter">'</span><span class="content">CellB1</span><span class="delimiter">'</span></span>,
        <span class="key">Header3</span>: <span class="string"><span class="delimiter">'</span><span class="content">CellC1</span><span class="delimiter">'</span></span>,
        <span class="key">Header4</span>: <span class="string"><span class="delimiter">'</span><span class="content">CellD1</span><span class="delimiter">'</span></span>
]
<span class="keyword">assert</span> resultSet[<span class="integer">0</span>].Header2 == <span class="string"><span class="delimiter">'</span><span class="content">CellB1</span><span class="delimiter">'</span></span>    <b class="conum">(2)</b>
<span class="keyword">assert</span> resultSet*.Header2 == [<span class="string"><span class="delimiter">'</span><span class="content">CellB1</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">CellB2</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">CellB3</span><span class="delimiter">'</span></span>]    <b class="conum">(3)</b>
<span class="keyword">assert</span> resultSet.Header1[<span class="integer">2</span>] == <span class="string"><span class="delimiter">'</span><span class="content">CellA3</span><span class="delimiter">'</span></span>    <b class="conum">(4)</b></pre></td>
</tr></table></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>If we take the first line of our resultset (hey! that&#8217;s an array notation for accessing a list position? yup! it certainly is!), we obtain a map with the first line of the csv file. Note the map creation notation; <strong>as with lists, it&#8217;s far more simpler than Java</strong>. Square brackets surrounding <em>key : value</em> pairs makes the job!</p>
</li>
<li>
<p><strong>Dot notation to the rescue here!</strong> If the first line is a map, the <code>map.key</code> notation gives you access to the value associated to that key.</p>
</li>
<li>
<p>What&#8217;s that asterisk here? It&#8217;s optional, but it denotes that <strong>we are accessing at all elements of the list at the same time</strong>. And since we are calling at the <code>Header2</code> key, we are retrieving all elements of the second column of the csv.</p>
</li>
<li>
<p>Here, like in the previous example, we are accessing to all elements of the third column, without the asterisk (it was optional, do you remember?), and then to the third element of the third column, again with the square brackets notation.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Eazy peazy lemon squeezy! Just think about <strong>the lines of code needed to achieve the same result in java</strong>. With lambdas they&#8217;re obviously decreased, but Groovy is still cleaner and more concise. I&#8217;ve skipped a lot of things and you&#8217;ve only seen the gist of Groovy, but you can easily intuit its real power.</p>
</div>
<div class="paragraph">
<p>One thing you have probably noticed is that <strong>there are no imports in the above code snippet</strong>. You can paste the code in a file and run it with the groovy CLI and it will run without complains. Java automatically imports the contents in the <code>java.lang</code> package, and Groovy also import other packages, like the <code>java.io</code> one.</p>
</div>
<div class="paragraph">
<p>Please, feel free to leave any comments and suggestions! Hope you liked it!</p>
</div>
</div>
</div>]]></description>
            </item>
        

    </channel>

</rss>